Serverless 架构
===

> 花了 200G，我终于弄清楚了 Serverless 是什么？

为了弄清 Serverless 究竟是什么东西？Serverless 到底是个什么？我使用 Serverless 尝试了一个又一个示例，自己做了四五个应用，总算是对 Serverelss 有了一个大致上的认识。现在，让我简单地解释『花了 40G，我终于弄清楚了 Serverless 是什么？』这句话，来说说 Serverless 到底是什么鬼？

什么是 Serverless 架构？？
---

> 开发人员为了保证开发环境的正确（即，这个 Bug 不是环境因素造成的），想出了一系列的隔离方式：虚拟机、容器虚拟化、语言虚拟机、应用容器（如 Java 的 Tomcat）、虚拟环境（如 Python 中的 virtualenv），甚至是独立于语言的 DSL。[^full_stack]

从最早的物理服务器开始，我们都在不断地抽象或者虚拟化服务器。

![服务器发展](images/server-growth.jpg)

 - 我们使用 XEN、KVM等虚拟化技术，隔离了硬件以及运行在这之上的操作系统。
 - 我们使用云计算进一步地自动管理这些虚拟化的资源。
 - 我们使用 Docker 等容器技术，隔离了应用的操作系统与服务器的操作。

现在，我们有了 Serverless，我们可以隔离操作系统，乃至更底层的技术细节。

### 为什么是花了 200G ？

这是一个非常好的问题。

在实践的过程中，我采用的是 AWS Lambda 作为 Serverless 服务背后的计算引擎。AWS Lambda 是一种函数即服务（Function-as-a-Servcie，FaaS）的计算服务，简单的来说就是：开发人员直接编写运行在云上的函数、功能、服务。由云服务产商提供操作系统、运行环境、网关等一系列的基础环境，我们只需要关注于编写我们的业务代码即可。

是的，你没听错，我们只需要**考虑怎么用代码提供价值即可**。我们甚至连可扩展、蓝绿部署等一系列的问题都不用考虑，Amazon 优秀的运营工程师已经帮助我们打造了这一系列的基础设施。并且与传统的 AWS 服务一样，如 Elastic Compute Cloud（EC2），它们都是按流量算钱的。

那么问题又来了，它到底是怎么对一个函数收钱的。我在 Lambda 函数上运行一个 Hello, world 它会怎么收我的钱呢？

如果要对一个运行的函数收费，那么想必只有运行时间、CPU、内存占用、硬盘这几个条件。可针对于不同的需求，提供不同的 CPU 是一件很麻烦的事。对于代码来说，一个应用占用的硬盘空间几乎可以忽略不计。当然，这些应用会在你的 S3 上有一个备份。于是，诸如 AWS 采用的是运行时间 + 内存的计算方式。

| 内存 (MB) | 	每个月的免费套餐秒数 |  每 100ms 的价格 (USD) |
|----------|---------------------|----------------------|
| 128	   |  3,200,000	         | 0.000000208          |
| 192	   | 2,133,333           | 0.000000313 			|
| 256	   | 1,600,000	         | 0.000000417  	 	|
| ...      | ...				 | ...					|	
| 1024	   | 400,000	         | 0.000001667          |
| ...      | ...				 | ...					|

在运行程序的时候，AWS 会统计出一个时间和内存，如下所示：

```
REPORT RequestId: 041138f9-bc81-11e7-aa63-0dbab83f773d	Duration: 2.49 ms	Billed Duration: 100 ms 	Memory Size: 1024 MB	Max Memory Used: 20 MB
```

其中的 ``Memory Size`` 即是我们选用的套餐类型，Duration 即是运行的时间，Max Memory Used 是我们应用运行时占用的内存。根据我们的 Max Memory Used 数值及应用的计算量，我们可以很轻松地计算出我们所需要的套餐。

因此，如果我们选用 1024M 的套餐，然后运行了 320 次，一共算是使用了 320G 的计算量。而其运行时间会被舍入到最近的 100ms，就算我们运行了 2.49ms，那么也是按 100ms 算的。那么假设，我们的 320 次计算都花了 1s，也就是 10*100ms，那么我们要支付的费用是：10*320*0.000001667=0.0053344刀，即使转成人民币也就是不到 4 毛钱的 0.03627392。

如果我们先用的是 128M 的套餐，那么运行了 2000 次，就是 200G 的计算量了。

不过如上表所示，AWS 为 Lambda 提供了一个免费套餐（无期限地提供给新老用户）包含每月 1M 免费请求以及每月 400 000 GB 秒的计算时间。这就意味着，在很长的时间里，我们一分钟都不用花。

### Serverless 是什么？

而从上节的内容中，我们可以知道这么几点：

 - 在 Serverless 应用中，开发者只需要专注于业务，剩下的运维等工作都不需要操心
 - Serverless 是**真正的按需使用**，请求到来时才开始运行
 - Serverless 是按运行时间和内存来算钱的
 - Serverless 应用严重依赖于特定的云平台、第三方服务

当然这些都是一些虚无缥缈地东西。

按 AWS 官方对于 Serverless 的介绍是这样的：

> 服务器架构是基于互联网的系统，其中应用开发不使用常规的服务进程。相反，它们仅依赖于第三方服务（例如AWS Lambda服务），客户端逻辑和服务托管远程过程调用的组合。”[^aws_serverless]

[^aws_serverless]: https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/

在一个基于 AWS 的 Serverless 应用里，应用的组成是：

 - 网关 API Gateway
 来接受和处理成千上万个并发 API 调用，包括流量管理、授权和访问控制、监控等
 - 计算服务 Lambda 来进行代码相关的一切计算工作，诸如授权验证、请求、输出等等
 - 基础设施管理 CloudFormation 来创建和配置 AWS 基础设施部署，诸如所使用的 S3 存储桶的名称等
 - 静态存储 S3 作为前端代码和静态资源存放的地方
 - 数据库 DynamoDB 来存储应用的数据
 - 等等

以博客系统为例，当我们访问一篇博客的时候，只是一个 GET 请求，可以由 S3 为我们提供前端的静态资源和响应的 HTML。

![Serverless SPA 架构](serverless-spa-architecture.png)

而当我们创建一个博客的时候：

 - 我们的请求先来到了 API Gateway，API Gateway 计费器 + 1
 - 接着请求来到了 Lambda，进行数据处理，如生成 ID、创建时间等等，Lambda 计费器 + 1
 - Lambda 在计算完后，将数据存储到 DynamoDB 上，DynamoDB 计费器 + 1
 - 最后，我们会生成静态的博客到 S3 上，而 S3 只在使用的时候按存储收费。

在这个过程中，我们使用了一系列稳定存在的云服务，并且只在使用时才计费。由于这些服务可以自然、方便地进行调用，我们实际上只需要关注在我们的 Lambda 函数上，以及如何使用这些服务完成整个开发流程。

因此，Serverless 并不意味着没有服务器，只是服务器以特定功能的第三方服务的形式存在。

当然并不一定使用这些云服务（如 AWS），才能称为 Serverless。诸如我的同事在 《[Serverless 实战：打造个人阅读追踪系统](https://blog.jimmylv.info/2017-06-30-serverless-in-action-build-personal-reading-statistics-system/)》，采用的是：IFTTT + WebTask + GitHub Webhook 的技术栈。它只是意味着，你所有的应用中的一部分服务直接使用的是第三方服务。

在这种情况下，系统间的分层可能会变成一个又一个的服务。原本，在今天主流的微服务设计里，每一个领域或者子域都是一个服务。而在 Serverless 应用中，这些领域及子域因为他们的功能，又可能会进一步切分成一个又一个 Serverless 函数。

![更小的函数](images/mono-ms-sls.jpg)

只是这些服务、函数比以往的粒度更加细致。

Serverless 的优势
---

### 降低成本

#### 减少运营成本

对于，初创公司来说，他们没有基础设施，也没有财力，也可能没有能力去建设基础设施。采用云服务往往是最好的选择，可以节省大量的资金。与此同时，诸如 AWS 这样庞大的系统，对于创业公司的程序员来说，也不能容易消化掉的一个系统。

而如果一家创业公司采用的是 Serverless，而不是使用云服务器。那么，他就会拥有更多的时间去开发，不需要担心维护。只需要为运行时的软件付钱。

按需计算就意味着，在请求到来的时候，才运行函数。没有请求的时候，是不算钱的。

#### 降低开发成本

当然，将应用设计成无状态应用，对于早期的系统，可能是一种挑战。

### 实现快速上线

在我使用 Serverless Framework 开发应用的过程中，最方便的莫过于，第一次部署和第二次、第三次部署没有什么区别。只需要执行``serverless deploy``，几分钟后，我们代码就运行在线上。如果是一个传统的 AWS 应用，我需要 SSH 到我的服务器上部署，这样才能写好我的自动部署脚本。除此，我还需要担忧这个过程中，有哪些用户有使用。

#### 更少的代码

更少的代码，意味着更少的 bug

#### 更快的开发速度

关注于业务，而非技术

### 运维成本

#### 减少运维开销

对于我而言，缺乏大量的后台架构实践经验，也需要大量的 DevOps。

不需要考虑系统底层安全问题，

### 系统安全性更高

我不再需要担心有人尝试登录系统, blabla

唯一需要担心的，可能是有人发起 DDOS 攻击。而根据[Could Zombie Toasters DDoS My Serverless Deployment?](https://thenewstack.io/zombie-toasters-eat-startup/)的计算

每百万的请求，大概是 0.2 刀，每小时 360000000 个请求，也就 72 刀。

### 适应微服务架构

微服务并不能替换大量的单体应用

优势：**编写单一用途的无状态函数**。

这一点与微服务是相当类似。

相似的，它们是相辅相成的。

### 自动扩展能力

Serverless 的背后是 诸如 AWS Lambda 这样的 FaaS（Function as a Services）。

对于传统应用来说，要应对更多的请求的方式，就是部署更多的实例。然而，这个时候往往已经来不及了。而对于 FaaS 来说，我们并不需要这么做，FaaS 会自动的扩展。它可以在需要时尽可能多地启动实例副本，而不会发生冗长的部署和配置延迟。

这依赖于我们的服务是无状态的，我们才能次无忌惮地不断运行起新的实例。

Serverless 的适用场景
---

 - 事件驱动的编程，如数据、聊天机器人等等
 - 移动应用
 - 物联网应用
 - 精益创业
 - 定时任务

### 发送通知（邮件、短信等）

事件触发，对实时性的要求相对没有那么高~~

### 轻量级 API

Serverless 特别适合于，轻量级快速变化地 API。

其实，我一直想举一个 Featrue Toggle 的例子，尽管有一些不合适。但是，可能是最有价值的部分。

### 数据统计

统计本身只需要很少的计算量，但是生成图表，则可以定期生成。

### 大量计算（AI）

低频高内存计算

### 物联网

如 IoT。

当我们谈及物联网的时候，我们会讨论事件触发、传输协议、海量数据（数据存储、数据分析）。

对接不同的硬件，本身就是一种挑战。

### Trigger 及定时任务

定时爬虫机器人

### 精益创业

快速验证一个想法 MVP。

Dropbox 创业历史的示例。

AWS 提供一系列的工具：

 - Cognito 用于用户授权
 - Dynamo 存储数据
 - Lambda 计算
 - API Gateway 进行 API
 - blabla

### Chat 机器人

聊天机器人，也是一个相当好的应用场景。

Message，

But，由于国内的条件限制（信息监管），这并不是一件容易的事。因此，从渠道（如微信、blabla）上，都在尽可能地降低这方面的可能性。

### 博客系统

过去的几年里，我一直在尝试将我的博客迁移到云服务上，而不是某个主机。

Serverless 的问题
---

### 完全依赖于云服务


应对方案，建立隔离层。

这意味着，你需要建议隔离层，

 - 隔离 API 网关
 - 隔离数据库层，考虑到市面上还没有成熟的 ORM 工具，让你即支持 Firebase，又支持 DynamoDB 

### 冷启动时间

据 New Relic 官方博客《[Understanding AWS Lambda Performance—How Much Do Cold Starts Really Matter?](https://blog.newrelic.com/2017/01/11/aws-lambda-cold-start-optimization/)》称，AWS Lambda 的冷启动时间。

![AWS 启动时间](aws-lambda-monitoring-functions-chart.png)

### 不适合长期运行应用

因为冷启动时间的存长，应用在

当然，可以结合 CRON 的方式来定期唤醒应用。

### 严重依赖第三方 API

是的，

在这种情况下，只能将不重要的 API 放在 Serverless 上。

当你已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。

### 缺乏调试和开发工具

你需要一遍又一遍地上传代码，每次上传的时候，你就好像是在部署服务器。然后 Fuck the。

当我使用 Serverless Framework 的时候，遇到了这样的问题。后来，我发现了 serverless-offline，问题有一些改善。

然而，对于日志系统来说，这仍然是一个艰巨的挑战。

### 构建复杂

Serverless 很便宜，但是这并不意味着它很简单。

早先，在知道 AWS Lambda 之后，我本来想进行一些尝试。但是 CloudForamtion 让我觉得太难了，它的配置是如此的复杂，并且难以编写。

我使用的是 Serverless，考虑到 CloudForamtion 的复杂度。

### 自然限制

使用多少内存、CPU 限制等等

### 语言版本落后

在 Node.js 6 出来的时候，AWS Lambda 只支持 Node.js 4.3.2；在 Node.js 9.0 出来的时候，AWS Lambda 支持到 6.10.3。

如下是 AWS Lambda 支持以下运行时版本：

 - Node.js – v4.3.2 和 6.10.3
 - Java - Java 8
 - Python – Python 3.6 和 2.7
 - .NET 内核 – .NET 内核 1.0.1 (C#)

如 Node.js

其它
---

### 迁移方案

Express 应用示例

### Serverless 框架

### Serverless

### Apex

### Apache OpenWhisk

[^full_stack]: 选自《全栈应用开发：精益实践》的『隔离与运行环境』一节
